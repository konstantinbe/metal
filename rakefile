#!/usr/bin/env ruby
#
# Copyright (c) 2010 Konstantin Bender.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

# ------------------------------------------------------------- Constants ------

BOLD = "\x1B[0;1m"
BLACK = "\x1B[0;30m"
RED = "\x1B[0;31m"
GREEN = "\x1B[0;32m"
YELLOW = "\x1B[0;33m"
BLUE = "\x1B[0;34m"
MAGENTA = "\x1B[0;35m"
CYAN = "\x1B[0;36m"
WHITE = "\x1B[0;37m"

BLACK_BRIGHT = "\x1B[1;30m"
RED_BRIGHT = "\x1B[1;31m"
GREEN_BRIGHT = "\x1B[1;32m"
YELLOW_BRIGHT = "\x1B[1;33m"
BLUE_BRIGHT = "\x1B[1;34m"
MAGENTA_BRIGHT = "\x1B[1;35m"
CYAN_BRIGHT = "\x1B[1;36m"
WHITE_BRIGHT = "\x1B[1;37m"

RESET = "\x1B[0m"

OK = GREEN + "OK" + RESET
FAILED = RED + "FAILED" + RESET

# ------------------------------------------------------------ Parameters ------

$configs = {}

$configs['clang'] = {:title => "Clang", :compiler => "clang", :flags => "-Wall -std=c99 -Wno-gnu -Wno-unused-function -Wno-unused-variable -Wno-pointer-sign"}
$configs['gcc'] = {:title => "GCC", :compiler => "gcc", :flags => "-Wall -std=c99 -Wno-unused-function -Wno-unused-variable"}
$configs['icc'] = {:title => "ICC", :compiler => "icc", :flags => "-Wall -std=c99 -Wno-unused-function -Wno-unused-variable"}

$configs['clang:debug'] = {:title => "Clang", :compiler => "clang", :flags => "-Wall -g -DDEBUG=1 -std=c99 -Wno-unused-function -Wno-unused-variable -O0"}
$configs['gcc:debug'] = {:title => "GCC", :compiler => "gcc", :flags => "-Wall -g -DDEBUG=1 -std=c99 -Wno-unused-function -Wno-unused-variable -O0"}
$configs['icc:debug'] = {:title => "ICC", :compiler => "icc", :flags => "-Wall -g -DDEBUG=1 -std=c99 -Wno-unused-function -Wno-unused-variable -O0"}

$configs['clang:profile'] = {:title => "Clang", :compiler => "clang", :flags => "-Wall -fprofile-arcs -ftest-coverage -std=c99 -Wno-unused-function -Wno-unused-variable"}

# ------------------------------------------------------ Default Compiler ------

CLANG_INSTALLED = `which clang 2> /dev/null`.size > 0
GCC_INSTALLED = `which gcc 2> /dev/null`.size > 0
ICC_INSTALLED = `which icc 2> /dev/null`.size > 0

$config = $configs["icc"] if ICC_INSTALLED
$config = $configs['gcc'] if GCC_INSTALLED
$config = $configs['clang'] if CLANG_INSTALLED

GDB_INSTALLED = `which gdb 2> /dev/null`.size > 0
LLDB_INSTALLED = `which lldb 2> /dev/null`.size > 0

$debugger = "gdb" if GCC_INSTALLED
$debugger = "lldb" if LLDB_INSTALLED

# ---------------------------------------------------------- Custom Tasks ------

task :build => ['build:library', 'build:tests', 'build:benchmarks'] do
end

task :analyze => [:prepare] do
  put "Analyzing Metal ... "
  run "cd build; #{compiler} --analyze #{flags} ../source/*.c"
  puts OK
end

task :profile => ['profile:collect', 'profile:details', 'profile:summary']

task 'profile:collect' => [:prepare] do
  configure 'clang:profile'

  put "Preparing ... "
  delete_file_if_exists "build/coverage"
  run "mkdir build/coverage"
  run "mkdir build/coverage/metal"
  puts OK

  put "Copying source files ... "
  run "cp source/*.h build/coverage/metal"
  run "cp source/*.c build/coverage"
  run "cp tests/*.c build/coverage"
  puts OK

  put "Building (#{$config[:title]}) ... "
  run "cd build/coverage; #{compiler} #{flags} -I../coverage -iquote../../source -iquote../../tests *.c -o coverage"
  puts OK

  put "Profiling (#{$config[:title]}) ... "
  run "cd build/coverage; ./coverage"
  puts OK
end

task 'profile:summary' => [:prepare, 'profile:collect'] do
  puts ""
  puts "--------------------------- Code Coverage Results ------"

  source_files = `cd source; find *.c`.split("\n").join(" ")
  raw = `cd build/coverage; gcov #{source_files} 2> gcov-error.log`

  results = raw.scan /File '(.*)'\nLines executed:(\d+\.\d+)% of (\d+)/
  results = results.reject do |result|
    result[0].start_with? "test" or result[0].start_with? "__" or result[0].include? "/" or result[2].include? "no functions found"
  end

  total_number_of_lines = 0
  total_number_of_lines_covered = 0

  details = results.collect do |result|
    detail = {}
    detail[:title] = result[0]
    detail[:fraction] = result[1].to_f / 100.0
    detail[:number_of_lines] = result[2].to_i
    detail[:number_of_lines_covered] = detail[:fraction] * detail[:number_of_lines]

    total_number_of_lines += detail[:number_of_lines]
    total_number_of_lines_covered += detail[:number_of_lines_covered]

    detail
  end

  details.reverse.each do |detail|
    color = :red
    color = :yellow if detail[:fraction] >= 0.7
    color = :green if detail[:fraction] >= 0.9

    title = detail[:title]
    fraction = (detail[:fraction] * 100).to_i.to_s + " %"
    number_of_lines = detail[:number_of_lines].to_s + " lines"

    printf "%-35s %30s %18s\n", colorize(title, :bright_cyan), colorize(number_of_lines, :black), colorize(fraction, color)
  end

  total_title = "Total"
  total_fraction = if total_number_of_lines != 0 then (total_number_of_lines_covered / total_number_of_lines) * 100 else 0 end
  total_number_of_lines = total_number_of_lines.to_s

  color = :red
  color = :yellow if total_fraction >= 70
  color = :green if total_fraction >= 90

  printf "\nUnit tests cover %s of %s executable lines of code.\n\n", colorize(total_fraction.to_i.to_s + " %", color), total_number_of_lines
end

task 'profile:details' => ['profile:collect'] do
  source_files = `cd source; find *.c`.split("\n").each do |source_file|
    raw = `cd build/coverage; gcov -f #{source_file} 2> gcov-error.log`

    results = raw.scan /Function '(.*)'\nLines executed:(\d+\.\d+)% of (\d+)/
    results = results.reject do |result|
      result[0].start_with? "_-" or result[0].start_with? "__" or result[0].include? "/" or result[2].include? "no functions found"
    end

    dashes = "-" * (80 - 6 - 6 - 1 - 1 - source_file.size)
    puts "\n------#{dashes} #{source_file} ------"

    details = results.collect do |result|
      detail = {}
      detail[:title] = result[0]
      detail[:fraction] = result[1].to_f / 100.0
      detail[:number_of_lines] = result[2].to_i
      detail[:number_of_lines_covered] = detail[:fraction] * detail[:number_of_lines]
      detail
    end

    details.reverse.each do |detail|
      color = :red
      color = :yellow if detail[:fraction] >= 0.7
      color = :green if detail[:fraction] >= 0.9

      title = detail[:title]
      fraction = (detail[:fraction] * 100).to_i.to_s + " %"
      number_of_lines = detail[:number_of_lines].to_s + " lines"

      printf "%-59s %30s %18s\n", colorize(title, :bright_cyan), colorize(number_of_lines, :black), colorize(fraction, color)
    end
  end
end

task :test => [:prepare, 'build:tests'] do
  puts "Running #{WHITE_BRIGHT}Metal#{RESET} Tests ... "
  code = run "cd build; ./test", :silent => true
  exit code
end

task :debug => [:prepare] do
  configure 'icc:debug' if ICC_INSTALLED
  configure 'gcc:debug' if GCC_INSTALLED
  configure 'clang:debug' if CLANG_INSTALLED

  invoke 'build:library'
  invoke 'build:tests'

  put "Running Metal Tests in #{$debugger.upcase} (#{$config[:title]}) ... "
  run "#{$debugger} build/test"
  puts OK
end

task :preprocess => [:prepare] do
  put "Preprocessing Metal Library (#{$config[:title]}) ... "

  run "#{compiler} -c #{flags} -E source/*.c > build/preprocessor.c"
  puts OK
end

task :valgrind => [:prepare] do
  configure 'icc:debug' if ICC_INSTALLED
  configure 'gcc:debug' if GCC_INSTALLED
  configure 'clang:debug' if CLANG_INSTALLED

  invoke 'build:library'
  invoke 'build:tests'

  put "Running Metal with Valgrind ... "
  run "valgrind --leak-check=full --track-origins=yes build/test"
  puts OK
end

task :benchmark => [:prepare, 'build:benchmarks'] do
  put "Running Metal Benchmarks (#{$config[:title]}) ... "
  run "build/benchmark"
  puts OK
end

task :prepare do
  run "mkdir build" unless File.exists? "build"
end

task :clean do
  put "Cleaning ... "
  delete_file_if_exists "build"
  puts OK
end

task 'build:library' => [:prepare] do
  put "Building Metal Library (#{$config[:title]}) ... "

  delete_file_if_exists "build/library"
  delete_file_if_exists "build/metal"

  run "mkdir build/library"
  run "mkdir build/metal"

  run "cd build/library; #{compiler} -c #{flags} ../../source/*.c"
  run "cd build/library; ar rcs metal.library *.o"
  run "cp build/library/metal.library build/metal"
  run "cp source/*.h build/metal"
  puts OK
end

task 'build:tests' => ['build:library'] do
  put "Building Metal Tests (#{$config[:title]}) ... "
  delete_file_if_exists "build/tests"
  run "mkdir build/tests"
  run "cd build/tests; #{compiler} #{flags} -I../ ../../tests/*.c ../metal/metal.library -o ../test"
  run "chmod +x build/test"
  puts OK
end

task 'build:benchmarks' => ['build:library'] do
  put "Building Metal Benchmarks (#{$config[:title]}) ... "
  delete_file_if_exists "build/benchmarks"
  run "mkdir build/benchmarks"
  run "cd build/benchmarks; #{compiler} #{flags} -I../ ../../benchmarks/*.c ../metal/metal.library -o ../benchmark"
  run "chmod +x build/benchmark"
  puts OK
end

task 'test:clang' do
  configure 'clang'
  invoke 'test'
end

task 'test:gcc' do
  configure 'gcc'
  invoke 'test'
end

task 'test:icc' do
  configure 'icc'
  invoke 'test'
end

# ------------------------------------------------------------- Functions ------

def assert(condition, message = "")
  unless condition
    puts message + "\n\n"
    exit 1
  end
end

def check(condition)
  unless condition
    puts FAILED
    exit 1
  end
end

def run(command, options = {})
  success = system command
  check success unless options[:silent]
  success
end

def put(string)
  print string
  STDOUT.flush
end

def invoke(task)
  Rake::Task[task].invoke
end

def delete_file_if_exists(path)
  run "rm -rf #{path}" if File.exists? path
end

def replace_in_file(file_path, pattern, replacement)
  string = nil
  File.open(file_path, "r") { |file| string = file.read }
  string.gsub! pattern, replacement
  File.open(file_path, "w") { |file| file.write string }
end

def configure(name)
  $config = $configs[name]
end

def compiler
  $config[:compiler]
end

def flags
  $config[:flags]
end

def colorize(string, color)
  color_code_begin = "\33[0m"
  color_code_end = "\33[0m"

  color_code_begin = "\33[30m" if color == :black
  color_code_begin = "\33[31m" if color == :red
  color_code_begin = "\33[32m" if color == :green
  color_code_begin = "\33[33m" if color == :yellow
  color_code_begin = "\33[34m" if color == :blue
  color_code_begin = "\33[35m" if color == :magenta
  color_code_begin = "\33[36m" if color == :cyan
  color_code_begin = "\33[37m" if color == :white

  color_code_begin = "\33[1;30m" if color == :bright_black
  color_code_begin = "\33[1;31m" if color == :bright_red
  color_code_begin = "\33[1;32m" if color == :bright_green
  color_code_begin = "\33[1;33m" if color == :bright_yellow
  color_code_begin = "\33[1;34m" if color == :bright_blue
  color_code_begin = "\33[1;35m" if color == :bright_magenta
  color_code_begin = "\33[1;36m" if color == :bright_cyan
  color_code_begin = "\33[1;37m" if color == :bright_white

  color_code_begin + string + color_code_end
end

def red(string)
  colorize string, :red
end

def green(string)
  colorize string, :green
end

def yellow(string)
  colorize string, :yellow
end

def blue(string)
  colorize string, :blue
end

def magenta(string)
  colorize string, :magenta
end

def cyan(string)
  colorize string, :cyan
end
