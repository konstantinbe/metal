#
# Copyright (c) 2010 Konstantin Bender.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

require 'rubygems'

# ------------------------------------------------------------- Constants ------

TERMINAL = STDOUT.tty?

BOLD = TERMINAL ? "\x1B[0;1m" : ""
BLACK = TERMINAL ? "\x1B[0;30m" : ""
RED = TERMINAL ? "\x1B[0;31m" : ""
GREEN = TERMINAL ? "\x1B[0;32m" : ""
YELLOW = TERMINAL ? "\x1B[0;33m" : ""
BLUE = TERMINAL ? "\x1B[0;34m" : ""
MAGENTA = TERMINAL ? "\x1B[0;35m" : ""
CYAN = TERMINAL ? "\x1B[0;36m" : ""
WHITE = TERMINAL ? "\x1B[0;37m" : ""

BLACK_BRIGHT = TERMINAL ? "\x1B[1;30m" : ""
RED_BRIGHT = TERMINAL ? "\x1B[1;31m" : ""
GREEN_BRIGHT = TERMINAL ? "\x1B[1;32m" : ""
YELLOW_BRIGHT = TERMINAL ? "\x1B[1;33m" : ""
BLUE_BRIGHT = TERMINAL ? "\x1B[1;34m" : ""
MAGENTA_BRIGHT = TERMINAL ? "\x1B[1;35m" : ""
CYAN_BRIGHT = TERMINAL ? "\x1B[1;36m" : ""
WHITE_BRIGHT = TERMINAL ? "\x1B[1;37m" : ""

RESET = TERMINAL ? "\x1B[0m" : ""

OK = GREEN + "OK" + RESET
FAILED = RED + "FAILED" + RESET

# ------------------------------------------------------------ Parameters ------

$configs = {}

$configs['clang'] = {:title => "Clang", :compiler => "clang", :flags => "-Wall -std=gnu99 -Wno-unused-function -Wno-unused-variable -Wno-pointer-sign"}
$configs['gcc'] = {:title => "GCC", :compiler => "gcc", :flags => "-Wall -std=gnu99 -Wno-unused-function -Wno-unused-variable"}
$configs['icc'] = {:title => "ICC", :compiler => "icc", :flags => "-Wall -std=gnu99 -Wno-unused-function -Wno-unused-variable"}

$configs['clang:debug'] = {:title => "Clang", :compiler => "clang", :flags => "-Wall -g -DDEBUG=1 -std=gnu99 -Wno-unused-function -Wno-unused-variable -O0"}
$configs['gcc:debug'] = {:title => "GCC", :compiler => "gcc", :flags => "-Wall -g -DDEBUG=1 -std=gnu99 -Wno-unused-function -Wno-unused-variable -O0"}
$configs['icc:debug'] = {:title => "ICC", :compiler => "icc", :flags => "-Wall -g -DDEBUG=1 -std=gnu99 -Wno-unused-function -Wno-unused-variable -O0"}

$configs['clang:profile'] = {:title => "Clang", :compiler => "clang", :flags => "-Wall -fprofile-arcs -ftest-coverage -std=gnu99 -Wno-unused-function -Wno-unused-variable"}

# ------------------------------------------------------ Default Compiler ------

CLANG_INSTALLED = `which clang 2> /dev/null`.size > 0
GCC_INSTALLED = `which gcc 2> /dev/null`.size > 0
ICC_INSTALLED = `which icc 2> /dev/null`.size > 0

$config = $configs["icc"] if ICC_INSTALLED
$config = $configs['gcc'] if GCC_INSTALLED
$config = $configs['clang'] if CLANG_INSTALLED

$config = $configs["icc"] if ENV['CC'] == "icc"
$config = $configs['gcc'] if ENV['CC'] == "gcc"
$config = $configs['clang'] if ENV['CC'] == "clang"

GDB_INSTALLED = `which gdb 2> /dev/null`.size > 0
LLDB_INSTALLED = `which lldb 2> /dev/null`.size > 0

$debugger = "gdb" if GDB_INSTALLED
$debugger = "lldb" if LLDB_INSTALLED

# ---------------------------------------------------------- Custom Tasks ------

desc "build everything"
task :build => ['build:library', 'build:tests', 'build:benchmarks'] do
end

desc "analyze code with the Clang Analyzer"
task :analyze => [:prepare] do
  put "Analyzing Metal ... "
  run "cd build; #{compiler} --analyze #{flags} ../source/*.c"
  puts OK
end

desc "profile code & report results"
task :profile => ['profile:collect', 'profile:details', 'profile:summary']

task 'profile:collect' => [:prepare] do
  configure 'clang:profile'

  put "Preparing ... "
  delete_file_if_exists "build/coverage"
  run "mkdir build/coverage"
  run "mkdir build/coverage/metal"
  puts OK

  put "Copying source files ... "
  run "cp source/*.h build/coverage/metal"
  run "cp source/*.c build/coverage"
  run "cp tests/*.c build/coverage"
  puts OK

  put "Building (#{$config[:title]}) ... "
  run "cd build/coverage; #{compiler} #{flags} -I../coverage -iquote../../source -iquote../../tests *.c -o coverage"
  puts OK

  puts "Profiling by running #{WHITE_BRIGHT}Metal#{RESET} tests (#{$config[:title]}) ..."
  run "cd build/coverage; ./coverage"
end

task 'profile:summary' => [:prepare, 'profile:collect'] do
  puts ""
  puts "--------------------------------------------------- Code Coverage Results ------"

  source_files = `cd source; find *.c`.split("\n").join(" ")
  raw = `cd build/coverage; gcov #{source_files} 2> gcov-error.log`

  results = raw.scan /File '(.*)'\nLines executed:(\d+\.\d+)% of (\d+)/
  results = results.reject do |result|
    result[0].start_with? "test" or result[0].start_with? "__" or result[0].include? "/" or result[2].include? "no functions found"
  end

  total_number_of_lines = 0
  total_number_of_lines_covered = 0

  details = results.collect do |result|
    detail = {}
    detail[:title] = result[0]
    detail[:fraction] = result[1].to_f / 100.0
    detail[:number_of_lines] = result[2].to_i
    detail[:number_of_lines_covered] = detail[:fraction] * detail[:number_of_lines]

    total_number_of_lines += detail[:number_of_lines]
    total_number_of_lines_covered += detail[:number_of_lines_covered]

    detail
  end

  details.reverse.each do |detail|
    color = RED
    color = YELLOW if detail[:fraction] >= 0.7
    color = GREEN if detail[:fraction] >= 0.9

    title = detail[:title]
    fraction = (detail[:fraction] * 100).to_i.to_s + " %"
    number_of_lines = detail[:number_of_lines_covered].round.to_s +  " of " + detail[:number_of_lines].to_s

    printf "#{CYAN_BRIGHT}%-40s #{BLACK_BRIGHT}%20s #{color}%18s#{RESET}\n", title, number_of_lines, fraction
  end

  total_title = "Total"
  total_fraction = if total_number_of_lines != 0 then (total_number_of_lines_covered / total_number_of_lines) * 100 else 0 end
  total_number_of_lines = total_number_of_lines.to_s

  color = RED
  color = YELLOW if total_fraction >= 70
  color = GREEN if total_fraction >= 90

  printf "\nUnit tests cover #{color}%s#{RESET} of %s executable lines of code.\n\n", total_fraction.to_i.to_s + " %", total_number_of_lines
end

desc ""
task 'profile:details' => ['profile:collect'] do
  source_files = `cd source; find *.c`.split("\n").each do |source_file|
    raw = `cd build/coverage; gcov -f #{source_file} 2> gcov-error.log`

    results = raw.scan /Function '(.*)'\nLines executed:(\d+\.\d+)% of (\d+)/
    results = results.reject do |result|
      result[0].start_with? "_-" or result[0].start_with? "__" or result[0].include? "/" or result[2].include? "no functions found"
    end

    dashes = "-" * (80 - 6 - 6 - 1 - 1 - source_file.size)
    puts "\n------#{dashes} #{source_file} ------"

    details = results.collect do |result|
      detail = {}
      detail[:title] = result[0]
      detail[:fraction] = result[1].to_f / 100.0
      detail[:number_of_lines] = result[2].to_i
      detail[:number_of_lines_covered] = detail[:fraction] * detail[:number_of_lines]
      detail
    end

    details.reverse.each do |detail|
      color = RED
      color = YELLOW if detail[:fraction] >= 0.7
      color = GREEN if detail[:fraction] >= 0.9

      title = detail[:title]
      fraction = (detail[:fraction] * 100).to_i.to_s + " %"
      number_of_lines = detail[:number_of_lines_covered].round.to_s + " of " +  detail[:number_of_lines].to_s

      printf "#{CYAN_BRIGHT}%-40s #{BLACK_BRIGHT}%20s #{color}%18s#{RESET}\n", title, number_of_lines, fraction
    end
  end
end

desc "build & run tests"
task :test => [:prepare, 'build:tests'] do
  puts "Running #{WHITE_BRIGHT}Metal#{RESET} Tests ... "
  code = run "cd build; ./test", :silent => true
  exit code
end

desc "build & run in debugger (gdb or lldb)"
task :debug => [:prepare] do
  configure 'icc:debug' if ICC_INSTALLED
  configure 'gcc:debug' if GCC_INSTALLED
  configure 'clang:debug' if CLANG_INSTALLED

  invoke 'build:library'
  invoke 'build:tests'

  put "Running Metal Tests in #{$debugger.upcase} (#{$config[:title]}) ... "
  run "#{$debugger} build/test"
  puts OK
end

desc "run preprocessor for metal only"
task :preprocess => [:prepare] do
  put "Preprocessing Metal Library (#{$config[:title]}) ... "

  run "#{compiler} -c #{flags} -E source/*.c > build/preprocessor.c"
  puts OK
end

desc "check for memory leaks with Valgrind"
task :valgrind => [:prepare] do
  configure 'icc:debug' if ICC_INSTALLED
  configure 'gcc:debug' if GCC_INSTALLED
  configure 'clang:debug' if CLANG_INSTALLED

  invoke 'build:library'
  invoke 'build:tests'

  put "Running Metal with Valgrind ... "
  run "valgrind --leak-check=full --track-origins=yes build/test"
  puts OK
end

desc "build & run benchmarks"
task :benchmark => [:prepare, 'build:benchmarks'] do
  put "Running Metal Benchmarks (#{$config[:title]}) ... "
  run "build/benchmark"
  puts OK
end

desc "build website"
task :website do
  require 'readcarpet' if available? 'redcarpet'
  invoke :prepare

  markdown = Redcarpet::Markdown.new Redcarpet::Render::HTML, :autolink => true, :space_after_headers => true

  put "Building website ... "
  run "mkdir -p build/website"
  run "rm -rf build/website/*"
  run "cp website/* build/website/"
  index_html = read_from_file "website/index.html"
  content_md = read_from_file "website/content.md"
  index_html = index_html.gsub "<!-- content.md -->", markdown.render(content_md)
  write_to_file index_html, "build/website/index.html"
  puts OK
end

desc "create the build directory"
task :prepare do
  run "mkdir build" unless File.exists? "build"
end

desc "delete the build directory"
task :clean do
  put "Cleaning ... "
  delete_file_if_exists "build"
  puts OK
end

desc "build the Metal library"
task 'build:library' => [:prepare] do
  put "Building Metal Library (#{$config[:title]}) ... "

  delete_file_if_exists "build/library"
  delete_file_if_exists "build/metal"

  run "mkdir build/library"
  run "mkdir build/metal"

  run "cd build/library; #{compiler} -c #{flags} ../../source/*.c"
  run "cd build/library; ar rcs metal.library *.o"
  run "cp build/library/metal.library build/metal"
  run "cp source/*.h build/metal"
  puts OK
end

desc "build all tests"
task 'build:tests' => ['build:library'] do
  put "Building Metal Tests (#{$config[:title]}) ... "
  run "cd build; #{compiler} #{flags} -I./ ../tests/*.c metal/metal.library -o test"
  run "chmod +x build/test"
  puts OK
end

desc "build all benchmarks"
task 'build:benchmarks' => ['build:library'] do
  put "Building Metal Benchmarks (#{$config[:title]}) ... "
  delete_file_if_exists "build/benchmarks"
  run "mkdir build/benchmarks"
  run "cd build/benchmarks; #{compiler} #{flags} -I../ ../../benchmarks/*.c ../metal/metal.library -o ../benchmark"
  run "chmod +x build/benchmark"
  puts OK
end

desc "test with Clang"
task 'test:clang' do
  configure 'clang'
  invoke 'test'
end

desc "test with GCC"
task 'test:gcc' do
  configure 'gcc'
  invoke 'test'
end

desc "test with ICC"
task 'test:icc' do
  configure 'icc'
  invoke 'test'
end

# ------------------------------------------------------------- Functions ------

def assert(condition, message = "")
  unless condition
    puts message + "\n\n"
    exit 1
  end
end

def check(condition)
  unless condition
    puts FAILED
    exit 1
  end
end

def run(command, options = {})
  success = system command
  check success unless options[:silent]
  success
end

def put(string)
  print string
  STDOUT.flush
end

def invoke(task)
  Rake::Task[task].invoke
end

def read_from_file(file_path)
  File.open(file_path, "r") { |file| file.read }
end

def write_to_file(string, file_path)
  File.open(file_path, "w") { |file| file.write string }
end

def delete_file_if_exists(path)
  run "rm -rf #{path}" if File.exists? path
end

def replace_in_file(file_path, pattern, replacement)
  string = read_from_file file_path
  string.gsub! pattern, replacement
  write_to_file file_path, string
end

def configure(name)
  $config = $configs[name]
end

def compiler
  $config[:compiler]
end

def flags
  $config[:flags]
end

def available?(name)
  if Gem::Specification.methods.include? 'find_all_by_name'
      !Gem::Specification.find_all_by_name(name).empty?
    else
      Gem.available? name
    end
end
